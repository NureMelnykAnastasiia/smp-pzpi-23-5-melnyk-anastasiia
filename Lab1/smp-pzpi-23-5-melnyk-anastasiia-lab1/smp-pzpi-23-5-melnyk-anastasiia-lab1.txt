Міністерство освіти і науки України 



Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




Звіт
з лабораторної роботи № 1
з дисципліни: "Скриптові мови програмування"











Виконала:
ст. гр. ПЗПІ-23-5
Мельник А.

Перевірив:
ст. викл. каф. ПІ
Сокорчук І. П.















Харків - 2025

1 ІСТОРІЯ ЗМІН

№ДатаВерсія звітуОпис змін та виправлень120.05.20251Створено розділи "Історія змін", "Завдання", "Опис виконаної роботи", "Висновки"226.05.20252Створено додаток А, додаток Б


2 ЗАВДАННЯ

     Для виконання завдання треба розробити Bash-скрипт, який обробляє експортований із сайту https://cist.nure.ua/ розклад занять для всіх груп потоку в форматі CSV та перетворює його у формат CSV для завантаження в Google Календар https://support.google.com/.
     Впродовж виконання необхідно ознайомитись з основними командами Bash для роботи з файлами та текстовими даними та навчитись використовувати команди "select", "ls", "awk", "sort", "uniq", "tee", "cat", "sed", "iconv" тощо


3 ОПИС ВИКОНАНОЇ РОБОТИ

     Повну версію програмного кода можна переглянути в додатку Б.
     Робота скрипта починається з обробки параметрів командного рядка. Якщо користувач передає --help або --version, скрипт виводить відповідну довідкову інформацію та завершує виконання. Якщо передано параметри -s або --silent, увімкнено "тихий режим", що означає, що фінальний результат не буде виводитись у вигляді таблиці в терміналі.
  1 if [[ "$1" == "--help" ]]; then
  2     echo "Використання: $0 [--help | --version] | [[-s|--silent] [назва_групи] файл.csv]"
  3     exit 0
  4 elif [[ "$1" == "--version" ]]; then
  5     echo "Версія: 1.0"
  6     exit 0
  7 elif [[ "$1" == "-s" || "$1" == "--silent" ]]; then
  8     silent_mode=true
  9 elif [[ "$1" == *.csv ]]; then
 10     input_csv="$1"
 11 elif [[ "$2" == *.csv ]]; then
 12     input_csv="$2"
 13     chosen_group="$1"
 14 fi
     Далі відбувається визначення вхідного CSV-файлу. Якщо його не вказано явно, скрипт здійснює пошук усіх відповідних CSV-файлів у поточній директорії (які відповідають шаблону TimeTable_??_??_20??.csv) та пропонує користувачеві вибрати один із них за допомогою інтерактивного меню select. 
  1 if [[ -z "$input_csv" ]]; then
  2     mapfile -t files_list < <(ls TimeTable_??_??_20??.csv 2>/dev/null | sort)
  3     if [[ ${#files_list[@]} -eq 0 ]]; then
  4         echo "CSV-файли не знайдені." >&2
  5         exit 1
  6     fi
  7     echo "Оберіть CSV-файл зі списку:"
  8     select f in "${files_list[@]}"; do
  9         if [[ -n "$f" ]]; then
 10             input_csv="$f"
 11             break
 12         else
 13             echo "Невірний вибір."
 14         fi
 15     done
 16 fi
     Після вибору або вказання CSV-файлу скрипт перевіряє доступність файлу для читання. Якщо файл недоступний, він завершується з повідомленням про помилку. Далі скрипт створює тимчасовий файл, куди перекодовує CSV із cp1251 у UTF-8 за допомогою утиліти iconv. Якщо перекодування не вдається, скрипт також завершується з відповідним повідомленням.
  1 utf_csv=$(mktemp)
  2 if ! iconv -f "$src_encoding" -t "$target_encoding" "$input_csv" > "$utf_csv"; then
  3     echo "Помилка перекодування." >&2
  4     exit 1
  5 fi
     Далі за допомогою grep виконується пошук унікальних назв груп у файлі. Якщо знайдено лише одну групу - вона вибирається автоматично. Якщо груп більше - користувачеві пропонується обрати групу вручну. Якщо користувач передає назву групи як параметр, скрипт перевіряє, чи така група є у файлі. Якщо ні - виводиться повідомлення про помилку та список доступних груп.
  1 mapfile -t group_list < <(grep -o 'ПЗПІ-[0-9]\+-[0-9]\+' "$utf_csv" | sort -u)
  2 
  3 if [[ ${#group_list[@]} -eq 0 ]]; then
  4     echo "Групи не знайдені у файлі." >&2
  5     rm -f "$utf_csv"
  6     exit 1
  7 fi
     Після цього скрипт переходить до обробки даних. Спочатку використовується sed, щоб замінити символи переносу рядків, і повторно виконується перекодування до UTF-8, а потім за допомогою awk відбувається основний етап обробки. Скрипт пропускає перший рядок (заголовки), а далі аналізує кожен запис. Визначаються й очищуються поля - дата, час, аудиторія, викладач, тип заняття (лекція, лабораторна, практична тощо), предмет і група. Дані розділяються на поля з урахуванням того, що CSV може містити вкладені лапки або коми у межах одного поля, тому парсинг робиться вручну символ за символом.
     Кожен запис фільтрується за групою, обраною користувачем. Для кожного заняття визначається "ключ сортування" - дата і час у форматі yyyymmddHHMM, який пізніше використовується для сортування. Коли всі записи зібрані, файл сортується за цим ключем.
     На наступному етапі інший awk-процес форматує записи у формат, сумісний із Google Calendar. Код з даною функціональністю наведено в рядках 91-195 в додатку Б. Дати переводяться з українського формату (дд.мм.рррр) у американський (мм/дд/рррр), а час - у 12-годинний формат з AM/PM. Назва предмета доповнюється номером/Для лабораторних занять застосовується окрема логіка, що не допускає дублювання однакових записів на одну й ту саму дату й час.
  1 if ($2 == "Лб") {
  2         if (!(dt in lab_seen)) {
  3             counter[id]++
  4             lab_seen[dt] = counter[id]
  5         }
  6         idx = lab_seen[dt]
  7     } else {
  8         counter[id]++
  9         idx = counter[id]
 10     }
     Після завершення форматування CSV-файл з результатами зберігається з префіксом Google_ і тією ж назвою, що й вхідний. Якщо скрипт не в тихому режимі - фінальний CSV виводиться у вигляді гарно вирівняної таблиці через команду column. Інакше - просто повідомляється про завершення обробки та назву збереженого файлу. Наприкінці усі тимчасові файли видаляються для звільнення ресурсів.
  1 if ! $silent_mode; then
  2     column -s, -t "$output_csv"
  3 else
  4     echo "Готовий CSV збережено як: $output_csv"
  5 fi
  6 
  7 rm -f "$utf_csv" "$tmp_data" "$tmp_sorted"



4 ВИСНОВКИ

     Отже, розроблений скрипт реалізує повний цикл обробки розкладу: від отримання CSV-файлу до формування структурованого файлу для імпорту в Google Calendar. Функціональна декомпозиція дозволяє легко масштабувати та підтримувати скрипт, а інтерактивні механізми вибору групи та файлу - підвищують зручність для користувача. Формат виводу відповідає стандартам Google, що забезпечує його практичне застосування без додаткового ручного редагування.


ДОДАТОК А
Відеозапис

Відеозапис презентації результатів лабораторної роботи: https://{URL}

Хронологічний опис відеозапису:

00:00 - Вступ



ДОДАТОК Б
Програмний код

GitHub репозиторій: https://github.

  1 #!/bin/bash
  2 src_encoding="cp1251"
  3 target_encoding="UTF-8"
  4 silent_mode=false
  5
  6 if [[ "$1" == "--help" ]]; then
  7     echo "Використання: $0 [--help | --version] | [[-s|--silent] [назва_групи] файл.csv]"
  8     exit 0
  9 elif [[ "$1" == "--version" ]]; then
 10     echo "Версія: 1.0"
 11     exit 0
 12 elif [[ "$1" == "-s" || "$1" == "--silent" ]]; then
 13     silent_mode=true
 14 elif [[ "$1" == *.csv ]]; then
 15     input_csv="$1"
 16 elif [[ "$2" == *.csv ]]; then
 17     input_csv="$2"
 18     chosen_group="$1"
 19 fi
 20
 21 if [[ -z "$input_csv" ]]; then
 22     mapfile -t files_list < <(ls TimeTable_??_??_20??.csv 2>/dev/null | sort)
 23     if [[ ${#files_list[@]} -eq 0 ]]; then
 24         echo "CSV-файли не знайдені." >&2
 25         exit 1
 26     fi
 27     echo "Оберіть CSV-файл зі списку:"
 28     select f in "${files_list[@]}"; do
 29         if [[ -n "$f" ]]; then
 30             input_csv="$f"
 31             break
 32         else
 33             echo "Невірний вибір."
 34         fi
 35     done
 36 fi
 37
 38 if [[ ! -r "$input_csv" ]]; then
 39     echo "Файл '$input_csv' недоступний або не існує." >&2
 40     exit 1
 41 fi
 42
 43 utf_csv=$(mktemp)
 44 if ! iconv -f "$src_encoding" -t "$target_encoding" "$input_csv" > "$utf_csv"; then
 45     echo "Помилка перекодування." >&2
 46     exit 1
 47 fi
 48
 49 mapfile -t group_list < <(grep -o 'ПЗПІ-[0-9]\+-[0-9]\+' "$utf_csv" | sort -u)
 50
 51 if [[ ${#group_list[@]} -eq 0 ]]; then
 52     echo "Групи не знайдені у файлі." >&2
 53     rm -f "$utf_csv"
 54     exit 1
 55 fi
 56
 57 selected=""
 58 if [[ -n "$chosen_group" ]]; then
 59     for gr in "${group_list[@]}"; do
 60         if [[ "$gr" == "$chosen_group" ]]; then
 61             selected="$gr"
 62             break
 63         fi
 64     done
 65     if [[ -z "$selected" ]]; then
 66         echo "Група '$chosen_group' відсутня у файлі." >&2
 67         printf "Доступні групи:\n%s\n" "${group_list[@]}" >&2
 68         rm -f "$utf_csv"
 69         exit 1
 70     fi
 71 else
 72     if [[ ${#group_list[@]} -eq 1 ]]; then
 73         selected="${group_list[0]}"
 74         echo "Автоматично вибрано: $selected"
 75     else
 76         PS3="Оберіть групу: "
 77         select g in "${group_list[@]}"; do
 78             if [[ -n "$g" ]]; then
 79                 selected="$g"
 80                 break
 81             fi
 82         done
 83     fi
 84 fi
 85
 86 base_name=$(basename "$input_csv")
 87 output_csv="Google_${base_name}"
 88 tmp_sorted=$(mktemp)
 89 tmp_data=$(mktemp)
 90
 91 sed 's/\r/\n/g' "$input_csv" | iconv -f cp1251 -t utf-8 | awk -v GR="$selected" '
 92 BEGIN {
 93     FS = ","; OFS = "\t"
 94 }
 95 NR == 1 { next }
 96
 97 function date_key(dt, tm) {
 98     split(dt, d, ".")
 99     split(tm, t, ":")
100     return sprintf("%04d%02d%02d%02d%02d", d[3], d[2], d[1], t[1], t[2])
101 }
102
103 function clean(s) {
104     gsub(/^"|"$/, "", s)
105     return s
106 }
107
108 {
109     line = $0
110     match(line, /"[0-3][0-9]\.[0-1][0-9]\.[0-9]{4}"/)
111     if (!RSTART) next
112     prefix = substr(line, 1, RSTART - 2)
113     rest = substr(line, RSTART)
114
115     n = 0; quote = 0; tmp = ""
116     for (i = 1; i <= length(rest); i++) {
117         c = substr(rest, i, 1)
118         if (c == "\"") quote = !quote
119         else if (c == "," && !quote) {
120             fields[++n] = tmp
121             tmp = ""
122         } else {
123             tmp = tmp c
124         }
125     }
126     fields[++n] = tmp
127     for (i = 1; i <= n; i++) fields[i] = clean(fields[i])
128     if (n < 12) next
129
130     match(prefix, /(ПЗПІ-[0-9]+-[0-9]+)/, m)
131     grp = m[1]
132     if (grp != GR) next
133
134     subj = substr(prefix, RSTART + RLENGTH)
135     gsub(/^[[:space:]-]+/, "", subj)
136     gsub(/^"+|"+$/, "", subj)
137     kind = "Інше"
138
139     if (fields[11] ~ /Лб/) kind = "Лб"
140     else if (fields[11] ~ /Лк/) kind = "Лк"
141     else if (fields[11] ~ /Пз/) kind = "Пз"
142     else if (fields[11] ~ /Екз/i) kind = "Екз"
143
144     key = date_key(fields[1], fields[2])
145     print subj, kind, fields[1], fields[2], fields[3], fields[4], fields[11], key
146 }' > "$tmp_data"
147
148 sort -t $'\t' -k8,8 "$tmp_data" > "$tmp_sorted"
149
150 awk -F'\t' '
151 BEGIN {
152     OFS = ","
153     print "Subject", "Start Date", "Start Time", "End Date", "End Time", "Description"
154 }
155
156 function us_date(d) {
157     split(d, p, ".")
158     return sprintf("%02d/%02d/%04d", p[2], p[1], p[3])
159 }
160
161 function ampm(t) {
162     split(t, h, ":")
163     hour = h[1] + 0
164     min = h[2]
165     mer = (hour >= 12) ? "PM" : "AM"
166     if (hour == 0) hour = 12
167     else if (hour > 12) hour -= 12
168     return sprintf("%02d:%s %s", hour, min, mer)
169 }
170
171 {
172     id = $1 "_" $2
173     dt = $3 "_" $7
174
175     if ($2 == "Лб") {
176         if (!(dt in lab_seen)) {
177             counter[id]++
178             lab_seen[dt] = counter[id]
179         }
180         idx = lab_seen[dt]
181     } else {
182         counter[id]++
183         idx = counter[id]
184     }
185
186     title = $1 "; №" idx
187     start_d = us_date($3)
188     start_t = ampm($4)
189     end_d = us_date($5)
190     end_t = ampm($6)
191     note = $7
192
193     printf "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n", \
194         title, start_d, start_t, end_d, end_t, note
195 }' "$tmp_sorted" > "$output_csv"
196
197 if ! $silent_mode; then
198     column -s, -t "$output_csv"
199 else
200     echo "Готовий CSV збережено як: $output_csv"
201 fi
202
203 rm -f "$utf_csv" "$tmp_data" "$tmp_sorted"


